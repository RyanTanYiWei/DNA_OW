---
title: "rDNA"
output: html_document
date: "2024-05-22"
---

# Install Necessary Packages
```{r eval=FALSE, include=FALSE}
install.packages("statnet")
install.packages("ergm")
install.packages("xergm")
install.packages("igraph")
install.packages("cluster")
install.packages("rJava")
install.packages("remotes")

# install.packages("remotes")
remotes::install_github("leifeld/dna/rDNA/rDNA@*release",
                        INSTALL_opts = "--no-multiarch")

```

# Initialize Library
```{r setup}
library(rJava)
.jinit()
.jcall("java/lang/System", "S", "getProperty", "java.runtime.version")

library(rDNA)
library(igraph)
library(ggplot2)
library(dplyr)
library(tidyr)
library(statnet)
library(RColorBrewer)
library(gridExtra)
set.seed(12345)
```

# Retrieve Network Data
```{r}
getwd()
dna_init()
dna_openDatabase(db_url = "FirstRun.dna", 
                 coderPasswor = "97863909")

dna_printDetails()
```

# Establish Color Scheme for Organizations
```{r}
# Extract Actor List
nodelist_org <- dna_getAttributes(statementType = "DNA Statement", variable = "organization") %>% 
  filter(!(is.na(value) | value == ""))

# Add Colors
unique_types <- unique(nodelist_org$Type)
num_colors <- length(unique_types)
colors <- brewer.pal(num_colors, "Paired") 
type_color_map <- setNames(colors, unique_types)
type_color_map

# Assign Colours in Actor List
nodelist_org <- nodelist_org %>%
  mutate(color = type_color_map[Type])
names(nodelist_org)[names(nodelist_org) == "value"] <- "organization"

```
# Network Projections

## Bipartite Network, Qualifier = Agreement) *Should colour based on Agreement Type

```{r fig.asp=1, fig.width=12, warning=FALSE}
# Two Mode Projection 
two <- dna_network(networkType = "twomode",
  variable1 = "organization",
  variable2 = "concept",
  qualifier = "agreement",
  qualifierAggregation = "combine",
  normalization = "no")

# Create Bipartite Graph
g_two <- graph_from_biadjacency_matrix((as.matrix(two)), 
                                       directed = FALSE,
                                       weighted = NULL,
                                       mode = "all")

# Set Edge Colors
colors <- as.character(t(two))
colors[colors=="1"] <- "green"
colors[colors=="2"] <- "indianred"
colors <- colors[colors != "0"] 

# Set Node Color
order <- match(V(g_one_org)$name, nodelist_org$value)
nodelist_org_ordered <- nodelist_org [order,]


g_two <- set_edge_attr(g_two, name = "color", value = colors)

plot.igraph(g_two, layout= layout_with_kk,
     edge.color = E(g_two)$color,
     vertex.color = c(rep("white", nrow(two)), rep("black", ncol(two))),
     vertex.size = 3)

```

# Network Projections (Actor Congruence)

```{r fig.asp=0.8, fig.width=12, warning=FALSE}

# One Mode Projection 
one_org <- dna_network(networkType = "onemode",
  variable1 = "organization",
  variable2 = "concept",
  qualifier = "agreement",
  qualifierAggregation = "congruence",
  normalization = "no")

# Create igraph graph
g_one_org <- graph_from_adjacency_matrix((as.matrix(one_org)), mode = "undirected", weighted = T, diag = F)

# Order Vertices
order <- match(V(g_one_org)$name, nodelist_org$organization)
nodelist_org_ordered <- nodelist_org [order,]

# Plot Graph
plot.igraph(union_N, 
            layout = layout_with_kk,
            vertex.size = 5,
            edge.width = E(g_one_org)$weight,
            edge.color = "grey",
            #vertex.label.cex = 0.9,
            vertex.label.cex = 0.8,
            vertex.color = nodelist_org_ordered$color,
            asp = 0.8,
            main = "Sample 100/377 Codings | Actor Congruence | Qualifier = NULL")

legend("bottomleft", legend = names(type_color_map), col = type_color_map, pch = 16, 
       title = "Types", cex = 0.8, pt.cex = 0.8, box.lwd = 0)
```

# Network Projections (Concept Congruence)

```{r fig.asp=0.7, fig.width=10, warning=FALSE}

# One Mode Projection 
one_conc <- dna_network(networkType = "onemode",
  variable1 = "concept",
  variable2 = "organization",
  qualifier = "no",
  qualifierAggregation = "congruence",
  normalization = "no")

# Create igraph graph
g_one_conc <- graph_from_adjacency_matrix((as.matrix(one_conc)), mode = "undirected", weighted = T, diag = F)

# Plot Graph
plot.igraph(g_one_conc, 
            layout = layout_with_fr,
            vertex.size = 5,
            edge.width = E(g_one_conc)$weight,
            edge.color = "grey",
            #vertex.label.cex = 0.9,
            vertex.label.cex = 0,
            main = "Sample 100/377 Codings | Concept Congruence | Qualifier = NULL")

```

## Actor Congruence based on specific concepts

```{r}
#list of concepts
concept_list <- dna_getAttributes(statementType = "DNA Statement", variable = "concept")$value
concept_list <- concept_list[concept_list!=""]
concept_list
```
### Plot All Concepts
```{r fig.asp=0.3, fig.width=40, warning=FALSE}
# Extract EdgeList for aLL concepts


#tiff(file="ActorCongruence.tif",width=6000, height=1400, units = "px", compression = "lzw")
png(file="ActorCongruence.png",width=6000, height=1400, units = "px", res = 200, pointsize = 5)
par(mfcol=c(2,8))
par(mar = c(0, 0, 0, 0)) 

#for (concept in concept_list){
for (concept in concept_list){ 
  print(concept)
  # network with concept
  nw <- dna_network(networkType = "twomode",
  variable1 = "organization",
  variable2 = "concept",
  qualifier = "agreement",
  qualifierAggregation = "combine",
  normalization = "no",
  excludeValues = list("concept" = concept),
  invertValues = TRUE
  )
  # create matrix of concepts based on agreements
  mat_Y <- as.data.frame(as.matrix(nw) ) %>% 
      filter(eval(parse(text = paste("`",concept,"`",sep="")))==1) %>% as.matrix()
  mat_N <- as.data.frame(as.matrix(nw) ) %>% 
      filter(eval(parse(text = paste("`",concept,"`",sep="")))==2) %>% as.matrix()
  
  # Extract Edges from this concept
  g_N<- graph_from_biadjacency_matrix(mat_N, 
                                         directed = FALSE,
                                         weighted = NULL,
                                         mode = "all") %>% 
                                      bipartite.projection(which = F)
  E(g_N)$concept_N <- 1
  #eval(parse(text = paste("E(g_N)$`", concept, "` <- 'red'"))) 
  
  g_Y<- graph_from_biadjacency_matrix(mat_Y, 
                                         directed = FALSE,
                                         weighted = NULL,
                                         mode = "all") %>% 
                                      bipartite_projection(which = F)
  #eval(parse(text = paste("E(g_Y)$`", concept, "` <- 'green'"))) 
  E(g_Y)$concept_Y <- 1
  
  
  # Plotting
  # Combining Plots to get attributes
  fullplot <- g_one_org
  union_N <- fullplot %u% g_N
  union_Y <- fullplot %u% g_Y
  
  # [for no] Place attributes into fullplot
  eval(parse(text = paste("E(fullplot)$`", concept, "N` <- ifelse(is.na(E(union_N)$concept_N), 'grey', ifelse(E(union_N)$concept_N == 1, 'red', original_array)) "))) 
  
  # [for no] Place attributes into fullplot
  eval(parse(text = paste("E(fullplot)$`", concept, "Y` <- ifelse(is.na(E(union_Y)$concept_Y), 'grey', ifelse(E(union_Y)$concept_Y == 1, 'green', original_array)) "))) 
  
  
  
  plot_N <- plot.igraph(union_N,
       edge.color = eval(parse(text = paste("E(fullplot)$`", concept, "N`"))),
       layout = layout_with_kk,
       vertex.label = NA,
       vertex.color = nodelist_org_ordered$color,
       vertex.size =3,
       asp = 0.8,
       #main = paste(concept)
       )
  
  
  plot_Y <- plot.igraph(union_N,
       edge.color = eval(parse(text = paste("E(fullplot)$`", concept, "Y`"))),
       layout = layout_with_kk,
       vertex.label = NA,
       vertex.color = nodelist_org_ordered$color,
       vertex.size =3,
       asp = 0.8,
       #main = paste(concept,"= Yes")
       )
  title(concept, cex.main=3, col.main="black",line = -2)
}

dev.off()
```

```{r fig.asp=1, fig.width=12, warning=FALSE}
concept_focus = "Decentralization is helpful"  
agreement = "Y"


# Two Mode Projection 
two_1 <- dna_network(networkType = "twomode",
  variable1 = "organization",
  variable2 = "concept",
  qualifier = "agreement",
  qualifierAggregation = "combine",
  normalization = "no",
  excludeValues = list("concept" = concept_focus),
  invertValues = TRUE
)

# Split Matrix based on Agreement

mat_Y <- as.data.frame(as.matrix(two_1) ) %>% 
  filter(eval(parse(text = paste("`",concept_focus,"`",sep="")))==1) %>% as.matrix()

mat_N <- as.data.frame(as.matrix(two_1) ) %>% 
  filter(eval(parse(text = paste("`",concept_focus,"`",sep="")))==2) %>% as.matrix()


# Extract Edges from this concept
g_N<- graph_from_biadjacency_matrix(mat_N, 
                                       directed = FALSE,
                                       weighted = NULL,
                                       mode = "all") %>% 
                                    bipartite.projection(which = F)
E(g_N)$concept_N <- 1
#eval(parse(text = paste("E(g_N)$`", concept, "` <- 'red'"))) 

g_Y<- graph_from_biadjacency_matrix(mat_Y, 
                                       directed = FALSE,
                                       weighted = NULL,
                                       mode = "all") %>% 
                                    bipartite_projection(which = F)
#eval(parse(text = paste("E(g_Y)$`", concept, "` <- 'green'"))) 
E(g_Y)$concept_Y <- 1


# Plotting
# Combining Plots to get attributes
fullplot <- g_one_org
union_N <- fullplot %u% g_N
union_Y <- fullplot %u% g_Y

# [for no] Place attributes into fullplot
eval(parse(text = paste("E(fullplot)$`", concept, "N` <- ifelse(is.na(E(union_N)$concept_N), 'grey', ifelse(E(union_N)$concept_N == 1, 'red', original_array)) "))) 

# [for no] Place attributes into fullplot
eval(parse(text = paste("E(fullplot)$`", concept, "Y` <- ifelse(is.na(E(union_Y)$concept_Y), 'grey', ifelse(E(union_Y)$concept_Y == 1, 'green', original_array)) "))) 

#E(union_N)$color <- ifelse(is.na(E(union_N)$concept_N), "grey", ifelse(E(union_N)$concept_N == 1, "red", original_array))


plot(union_N,
     edge.color = eval(parse(text = paste("E(fullplot)$`", concept, "N`"))),
     layout = layout_with_kk,
     vertex.label = NA,
     vertex.color = nodelist_org_ordered$color,
     vertex.size =3,
     main = paste(concept_focus,"=",agreement)
     )

plot(union_N,
     edge.color = eval(parse(text = paste("E(fullplot)$`", concept, "Y`"))),
     layout = layout_with_kk,
     vertex.label = NA,
     vertex.color = nodelist_org_ordered$color,
     vertex.size =3,
     main = paste(concept_focus,"=",agreement)
     )




```

```{r}

# Extract Edges from this concept

#full
g_two1 <- graph_from_biadjacency_matrix(as.matrix(two_1), 
                                       directed = FALSE,
                                       weighted = NULL,
                                       mode = "all")
g_two1 <- bipartite_projection(g_two1, which = F)
E(g_two1)$concept <- 1

# full actor congruenc eplot
fullplot <- g_one_org
E(fullplot)$concept <- 0


g_union <- fullplot %u% g_two1


E(g_union)$color <- ifelse(is.na(E(g_union)$concept_2), "grey", ifelse(E(g_union)$concept_2 == 1, "green", original_array))


plot(g_union,
     edge.color = E(g_union)$color,
     layout = layout_with_kk,
     vertex.label = NA,
     vertex.color = nodelist_org_ordered$color,
     vertex.size =3,
     main = concept_focus)

```




# Data

## Barplot of concepts

```{r}
b <- dna_barplot(statementType = "DNA Statement",
                 variable = "concept") 

# Reshape the dataframe from wide to long format
df_long <- b %>%
  gather(key = "agreement", value = "count", `0`, `1`) %>%
  mutate(count = ifelse(agreement == "0", -count, count))

# Create the diverging bar plot
ggplot(df_long, aes(x = reorder(Entity, count), y = count, fill = agreement)) +
  geom_bar(stat = "identity", position = "identity") +

  scale_fill_manual(values = c("red", "green"), 
                    labels = c("Disagreements", "Agreements")) +
  coord_flip() +
  labs(
    title = "Concepts",
    x = "",
    y = "Statement Count"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom") +
  guides(fill = guide_legend(title = "Agreement Type"))

```

## Barplot of Coalitions

```{r}
b1 <- dna_barplot(statementType = "DNA Statement",
                 variable = "organization") 
df <- b1 %>% 
  group_by(Type) %>% 
  summarize(`0` = sum(`0`), `1` = sum(`1`)) %>% 
  as.data.frame() %>% 
  rename("Entity" = "Type")

# Reshape the dataframe from wide to long format
df_long <- df %>%
  gather(key = "agreement", value = "count", -Entity) %>%
  mutate(count = ifelse(agreement == "0", -count, count))

# Create the diverging bar plot
ggplot(df_long, aes(x = reorder(Entity, count), y = count, fill = agreement)) +
  geom_bar(stat = "identity", position = "identity") +

  scale_fill_manual(values = c("red", "green"), 
                    labels = c("Sceptical", "Enthusiastic")) +
  coord_flip() +
  labs(
    title = "Organization Type",
    x = "",
    y = "Actor Count"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom") +
  guides(fill = guide_legend(title = "Coalition Type"))

```
## Barplot of Actors

```{r fig.height=8}
b <- dna_barplot(statementType = "DNA Statement",
                 variable = "organization") 

# Reshape the dataframe from wide to long format
df_long <- b %>%
  gather(key = "agreement", value = "count", `0`, `1`) %>%
  mutate(count = ifelse(agreement == "0", -count, count))

# Create the diverging bar plot
ggplot(df_long, aes(x = reorder(Entity, count), y = count, fill = agreement)) +
  geom_bar(stat = "identity", position = "identity") +

  scale_fill_manual(values = c("red", "green"), 
                    labels = c("Disagreements", "Agreements")) +
  coord_flip() +
  labs(
    title = "Concepts",
    x = "",
    y = "Statement Count"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom") +
  guides(fill = guide_legend(title = "Agreement Type"))


```

# Barplot of Concept Shares
```{r fig.asp=0.4, fig.width=10, warning=FALSE}
event_list <- dna_network(networkType = "eventlist",
  variable1 = "organization",
  variable2 = "concept",
  qualifier = "agreement",
  qualifierAggregation = "congruence",
  normalization = "no")

#event_list %>%
#  filter(concept == "")

#add count per category
merged_df <- merge(event_list, nodelist_org, by = "organization", all.x = TRUE) %>%
  filter(concept!= "") %>% ##REMEMBER TO REMOVE WHEN DATA IS PERFECTED
  group_by(concept,agreement,Type,color) %>%
  summarize(count = n()) 

#change concept name to include agreement typ  + yes or no
merged_df$concept <- ifelse(merged_df$agreement == 1, paste(merged_df$concept, "(yes)", sep = " "), 
                                 paste(merged_df$concept, "(no)", sep = " "))
#merged_df = merged_df %>% subset(select = -agreement)

#add calculate proportion
concept_total <- merged_df %>%
  group_by(concept) %>%
  summarize(total_count = sum(count))
merged_df  <- merged_df  %>%
  left_join(concept_total, by = "concept") %>%
  mutate(proportion = count / total_count)

merged_df


# Plot the horizontal barplot
ggplot(merged_df, aes(y = concept, x = proportion, fill = Type)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = merged_df$color) +
  labs(title = "Proportion of Statements by Actor Type",
       x = "Proportion",
       y = "") +
  theme_minimal() +
  theme(axis.text.y = element_text(hjust = 1))


```


# Time Series
```{r}


```
